// Web IDL code goes here

enum HAPI_Result {
"HAPI_RESULT_SUCCESS",
"HAPI_RESULT_FAILURE",	
"HAPI_RESULT_ALREADY_INITIALIZED", 	
"HAPI_RESULT_NOT_INITIALIZED", 	
"HAPI_RESULT_CANT_LOADFILE", 	
"HAPI_RESULT_PARM_SET_FAILED", 	
"HAPI_RESULT_INVALID_ARGUMENT", 	
"HAPI_RESULT_CANT_LOAD_GEO", 	
"HAPI_RESULT_CANT_GENERATE_PRESET", 	
"HAPI_RESULT_CANT_LOAD_PRESET", 	
"HAPI_RESULT_ASSET_DEF_ALREADY_LOADED", 	
"HAPI_RESULT_NO_LICENSE_FOUND", 	
"HAPI_RESULT_DISALLOWED_NC_LICENSE_FOUND", 	
"HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_C_LICENSE", 	
"HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_LC_LICENSE", 	
"HAPI_RESULT_DISALLOWED_LC_ASSET_WITH_C_LICENSE", 	
"HAPI_RESULT_DISALLOWED_HENGINEINDIE_W_3PARTY_PLUGIN", 	
"HAPI_RESULT_ASSET_INVALID", 	
"HAPI_RESULT_NODE_INVALID", 	
"HAPI_RESULT_USER_INTERRUPTED", 	
"HAPI_RESULT_INVALID_SESSION" 
};
 enum HAPI_PackedPrimInstancingMode
{
"HAPI_PACKEDPRIM_INSTANCING_MODE_INVALID",
"HAPI_PACKEDPRIM_INSTANCING_MODE_DISABLED",
"HAPI_PACKEDPRIM_INSTANCING_MODE_HIERARCHY",
"HAPI_PACKEDPRIM_INSTANCING_MODE_FLAT",
"HAPI_PACKEDPRIM_INSTANCING_MODE_MAX"
};

[Internal="HAPI_ThriftServerOptions"]
interface ServerOptions {
	void ServerOptions();

    attribute bool autoClose;
    attribute float timeoutMs;

    [CObject, Internal="HAPI_StartThriftNamedPipeServer",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int startNamedPipeServer( [Const] String name,  int[] pid);
    [CObject, Internal="HAPI_StartThriftSocketServer",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int startSocketServer( int port,  int[] pid);
};
	

[Internal="HAPI_CookOptions"]
interface CookOptions {
	void CookOptions();
	attribute bool splitGeosByGroup;
	attribute bool splitGeosByAttribute;
	attribute bool splitAttrSH;
	attribute int maxVerticesPerPrimitive;
	attribute bool  refineCurveToLinear;
	attribute float curveRefineLOD;
	attribute bool clearErrorsAndWarnings;
	attribute bool cookTemplatedGeos;
	attribute bool splitPointsByVertexAttributes;
	attribute bool handleBoxPartTypes;
    attribute bool handleSpherePartTypes;
	attribute bool checkPartChanges;
	attribute bool cacheMeshTopology;

//	attribute int packedPrimInstancingMode;
};
[Internal="HAPI_Session"]
interface Session {
	void Session();
	attribute int id;

    [CObject, Internal="HAPI_CreateThriftSocketSession",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int connectBySocket( [Const] String hostname,  int port);
    [CObject, Internal=" HAPI_Initialize",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int initialize( CookOptions cookOptions , bool cookThreads, int cookingStackSize, String environmentFiles, String otlsearch, String dsosearch, String imagedsosearch, String audiodsosearch);
    [CObject, Internal="HAPI_CloseSession",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int close();
    [CObject, Internal="HAPI_IsSessionValid",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int isValid();
    [CObject, Internal="HAPI_IsInitialized",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int isInitialized();
    [CObject, Internal="HAPI_Cleanup",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int cleanup();

	// Assets
    [CObject, Internal="HAPI_LoadAssetLibraryFromFile",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int loadAssetLibraryFromFile(String path, bool allowOverwrite, [Return] int libraryID);

	//HIP File
    [CObject, Internal="HAPI_LoadHIPFile",Validate="HAPI_RESULT_SUCCESS", Throw="Houdini::GetLastCallError(___retvalue)"] int loadHIP(String path, bool cook);
	


};

    /*
	void btVector3();
	void btVector3(float x, float y, float z);
	float length();
	float x();
	float y();
	float z();
	void setX(float x);
	void setY(float y);
	void setZ(float z);
	void setValue(float x, float y, float z);
	void normalize();
	[Value] btVector3 rotate([Ref] btVector3 wAxis, float angle);
	float dot([Ref] btVector3 v);
	[Operator="*=", Ref] btVector3 op_mul(float x);
	[Operator="+=", Ref] btVector3 op_add([Ref] btVector3 v);
	[Operator="-=", Ref] btVector3 op_sub([Ref] btVector3 v);
    */    /*
interface btCollisionWorld {

	btDispatcher getDispatcher();
	void rayTest([Const, Ref] btVector3 rayFromWorld, [Const, Ref] btVector3 rayToWorld, [Ref] RayResultCallback resultCallback);
	btOverlappingPairCache getPairCache();
	[Ref] btDispatcherInfo getDispatchInfo();
	void addCollisionObject(btCollisionObject collisionObject, optional short collisionFilterGroup, optional short collisionFilterMask);
	[Const] btBroadphaseInterface getBroadphase();
	void convexSweepTest([Const] btConvexShape castShape, [Const, Ref] btTransform from, [Const, Ref] btTransform to, [Ref] ConvexResultCallback resultCallback, float allowedCcdPenetration);
	void contactPairTest([Const] btCollisionObject colObjA, [Const] btCollisionObject colObjB, [Ref] ContactResultCallback resultCallback);
	void contactTest([Const] btCollisionObject colObj, [Ref] ContactResultCallback resultCallback);
    
};*/